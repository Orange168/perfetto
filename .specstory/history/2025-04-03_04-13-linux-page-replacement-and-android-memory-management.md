<!-- Generated by SpecStory -->

# Linux Page Replacement and Android Memory Management (2025-04-03 12:13:29)

_**User**_

Q: "请详细描述 Linux 的页面置换算法，以及 Android 如何处理内存紧张情况？结合 lowmemorykiller 和 OOM killer 机制展开。"

期望答点：
- 页面置换算法（LRU 等）
- Android 的内存回收机制
- Lowmemorykiller 的优先级策略
- OOM 评分机制


---

_**Assistant**_

I'll search for information in the codebase about Linux page replacement algorithms, Android memory management, lowmemorykiller, and OOM killer mechanisms.

---

<details>
            <summary>Searched codebase "Android lowmemorykiller OOM killer memory management" • **25** results</summary>
        
| File | Lines |
|------|-------|
| `docs/data-sources/memory-counters.md` | L307-415 |
| `src/trace_processor/perfetto_sql/stdlib/android/oom_adjuster.sql` | L58-124 |
| `docs/data-sources/memory-counters.md` | L189-307 |
| `src/trace_processor/perfetto_sql/stdlib/android/memory/process.sql` | L1-28 |
| `test/cts/art_module/heapprofd_java_test_cts.cc` | L1-49 |
| `src/trace_processor/importers/systrace/systrace_parser.cc` | L360-390 |
| `protos/perfetto/metrics/android/lmk_reason_metric.proto` | L1-56 |
| `tools/java_heap_dump` | L153-215 |
| `test/cts/test_apps/src/android/perfetto/cts/app/JavaOomActivity.java` | L23-53 |
| `src/profiling/memory/heapprofd_producer.cc` | L1-73 |
| `protos/perfetto/metrics/perfetto_merged_metrics.proto` | L1860-1929 |
| `src/trace_processor/perfetto_sql/stdlib/android/oom_adjuster.sql` | L1-58 |
| `protos/perfetto/metrics/perfetto_merged_metrics.proto` | L1929-1997 |
| `src/trace_processor/metrics/sql/android/mem_stats_priority_breakdown.sql` | L1-47 |
| `src/traced/probes/ftrace/test/data/android_seed_N2F62_3.10.49/events/lowmemorykiller/lowmemory_kill/format` | L1-16 |
| `src/trace_processor/metrics/sql/android/android_lmk.sql` | L1-64 |
| `src/traced/probes/ftrace/test/data/android_walleye_OPM5.171019.017.A1_4.4.88/events/lowmemorykiller/lowmemory_kill/format` | L1-16 |
| `ui/src/plugins/dev.perfetto.RecordTraceV2/pages/memory.ts` | L291-317 |
| `protos/perfetto/metrics/android/lmk_metric.proto` | L1-36 |
| `test/cts/art_module/heapprofd_java_test_cts.cc` | L49-97 |
| `src/trace_processor/importers/ftrace/ftrace_parser.cc` | L2216-2254 |
| `test/configs/camera.cfg` | L1-64 |
| `src/trace_processor/importers/proto/atoms.descriptor` | L375-593 |
| `src/profiling/memory/shared_ring_buffer.cc` | L1-67 |
| `protos/perfetto/trace/ftrace/lowmemorykiller.proto` | L1-15 |

</details>

---

Let me search for more information on Linux page replacement algorithms and OOM handling.

---

<details>
            <summary>Searched codebase "Linux page replacement algorithm LRU memory management" • **25** results</summary>
        
| File | Lines |
|------|-------|
| `src/traced/probes/filesystem/lru_inode_cache.cc` | L1-59 |
| `src/traced/probes/filesystem/lru_inode_cache.h` | L1-55 |
| `docs/case-studies/memory.md` | L90-127 |
| `src/base/paged_memory.cc` | L121-163 |
| `src/tracing/core/shared_memory_abi.cc` | L269-320 |
| `src/base/paged_memory.cc` | L1-64 |
| `src/tracing/core/shared_memory_abi.cc` | L182-229 |
| `src/base/test/vm_test_utils.cc` | L59-105 |
| `src/tracing/core/shared_memory_arbiter_impl.cc` | L137-189 |
| `src/base/test/vm_test_utils.cc` | L105-126 |
| `src/traced/probes/ps/process_stats_data_source.cc` | L608-658 |
| `src/traced/probes/ftrace/test/data/android_raven_AOSP.MASTER_5.10.43/events/pagemap/mm_lru_insertion/format` | L1-15 |
| `src/base/paged_memory_unittest.cc` | L1-59 |
| `src/base/test/vm_test_utils.cc` | L1-59 |
| `src/traced/probes/ftrace/cpu_reader.h` | L63-111 |
| `src/ipc/buffered_frame_deserializer.cc` | L1-55 |
| `src/traced/probes/ftrace/test/data/android_flounder_lte_LRX16F_3.10.40/events/kmem/mm_page_alloc_zone_locked/format` | L1-14 |
| `src/traced/probes/ps/process_stats_data_source.cc` | L658-694 |
| `src/traced/probes/ftrace/test/data/android_walleye_OPM5.171019.017.A1_4.4.88/events/pagemap/mm_lru_insertion/format` | L1-15 |
| `src/base/utils.cc` | L1-97 |
| `src/traced/probes/ftrace/test/data/android_flounder_lte_LRX16F_3.10.40/events/kmem/mm_page_free/format` | L1-13 |
| `src/tracing/core/shared_memory_abi.cc` | L1-53 |
| `src/base/utils.cc` | L142-203 |
| `src/tracing/core/shared_memory_arbiter_impl.cc` | L779-831 |
| `src/base/watchdog_posix.cc` | L230-284 |

</details>

---

Let me search for more specific information on Android's OOM killer.

---

<details>
            <summary>Searched codebase "Android OOM killer score calculation priority" • **25** results</summary>
        
| File | Lines |
|------|-------|
| `src/trace_processor/metrics/sql/android/mem_stats_priority_breakdown.sql` | L1-47 |
| `docs/data-sources/memory-counters.md` | L307-415 |
| `src/trace_processor/perfetto_sql/stdlib/android/oom_adjuster.sql` | L1-58 |
| `src/trace_processor/metrics/sql/android/android_lmk.sql` | L1-64 |
| `src/trace_processor/perfetto_sql/stdlib/android/oom_adjuster.sql` | L58-124 |
| `src/trace_processor/metrics/sql/android/process_oom_score.sql` | L1-29 |
| `src/trace_processor/perfetto_sql/stdlib/android/memory/process.sql` | L1-28 |
| `src/trace_processor/perfetto_sql/stdlib/android/oom_adjuster.sql` | L124-157 |
| `src/trace_processor/importers/systrace/systrace_parser.cc` | L360-390 |
| `src/trace_processor/perfetto_sql/stdlib/android/oom_adjuster.sql` | L157-200 |
| `test/trace_processor/diff_tests/metrics/memory/android_mem_by_priority.py` | L1-56 |
| `src/trace_processor/metrics/sql/android/android_oom_adjuster.sql` | L1-47 |
| `src/trace_processor/perfetto_sql/stdlib/android/memory/process.sql` | L75-100 |
| `protos/perfetto/metrics/android/lmk_reason_metric.proto` | L1-56 |
| `protos/perfetto/metrics/perfetto_merged_metrics.proto` | L1929-1997 |
| `protos/perfetto/metrics/android/lmk_metric.proto` | L1-36 |
| `src/trace_processor/perfetto_sql/stdlib/android/memory/process.sql` | L28-75 |
| `src/trace_processor/metrics/sql/android/android_lmk_reason.sql` | L1-55 |
| `src/trace_processor/importers/ftrace/ftrace_parser.cc` | L2216-2254 |
| `src/trace_processor/metrics/sql/android/android_boot.sql` | L1-57 |
| `src/trace_processor/perfetto_sql/stdlib/android/binder.sql` | L158-248 |
| `src/trace_processor/metrics/sql/android/java_heap_stats.sql` | L52-107 |
| `protos/perfetto/metrics/perfetto_merged_metrics.proto` | L1860-1929 |
| `src/trace_processor/metrics/sql/android/process_unagg_mem_view.sql` | L1-30 |
| `protos/perfetto/metrics/android/java_heap_stats.proto` | L1-53 |

</details>

---

Now let me search for information about lowmemorykiller and Linux page replacement specifically.

---

<details>
            <summary>Searched codebase "lowmemorykiller algorithm implementation" • **25** results</summary>
        
| File | Lines |
|------|-------|
| `protos/perfetto/trace/ftrace/lowmemorykiller.proto` | L1-15 |
| `docs/data-sources/memory-counters.md` | L307-415 |
| `src/traced/probes/ftrace/test/data/android_seed_N2F62_3.10.49/events/lowmemorykiller/lowmemory_kill/format` | L1-16 |
| `docs/data-sources/memory-counters.md` | L189-307 |
| `src/traced/probes/ftrace/test/data/android_walleye_OPM5.171019.017.A1_4.4.88/events/lowmemorykiller/lowmemory_kill/format` | L1-16 |
| `src/profiling/memory/bookkeeping_dump.cc` | L1-52 |
| `src/trace_processor/sorter/trace_sorter.cc` | L95-148 |
| `src/trace_processor/sorter/trace_sorter.cc` | L193-239 |
| `src/traced/probes/ftrace/event_info.cc` | L7100-7122 |
| `src/base/watchdog_posix.cc` | L230-284 |
| `src/traced/probes/ps/process_stats_data_source.cc` | L548-608 |
| `src/trace_processor/sorter/trace_sorter.cc` | L148-193 |
| `src/traced/probes/sys_stats/sys_stats_data_source.cc` | L56-106 |
| `src/profiling/memory/bookkeeping.h` | L142-162 |
| `src/base/utils.cc` | L142-203 |
| `src/tracing/core/shared_memory_abi.cc` | L269-320 |
| `src/trace_processor/importers/memory_tracker/graph_processor.cc` | L213-253 |
| `src/profiling/memory/shared_ring_buffer.cc` | L1-67 |
| `src/traced/probes/ftrace/ftrace_config_muxer.cc` | L1-67 |
| `src/trace_processor/perfetto_sql/stdlib/android/oom_adjuster.sql` | L58-124 |
| `src/profiling/memory/java_hprof_producer.cc` | L1-59 |
| `src/trace_processor/importers/systrace/systrace_parser.cc` | L360-390 |
| `src/base/watchdog_posix.cc` | L323-356 |
| `src/kallsyms/lazy_kernel_symbolizer.cc` | L47-93 |
| `src/traced/probes/ftrace/ftrace_config_muxer.cc` | L1080-1119 |

</details>

---

Now I'll search for more information on Linux LRU page replacement algorithm.

---

<details>
            <summary>Searched codebase "Linux page replacement LRU algorithm" • **25** results</summary>
        
| File | Lines |
|------|-------|
| `src/traced/probes/filesystem/lru_inode_cache.cc` | L1-59 |
| `src/traced/probes/filesystem/lru_inode_cache.h` | L1-55 |
| `src/base/paged_memory.cc` | L121-163 |
| `src/traced/probes/ftrace/test/data/android_raven_AOSP.MASTER_5.10.43/events/pagemap/mm_lru_insertion/format` | L1-15 |
| `src/tracing/core/shared_memory_abi.cc` | L269-320 |
| `docs/case-studies/memory.md` | L90-127 |
| `src/base/test/vm_test_utils.cc` | L59-105 |
| `src/tracing/core/shared_memory_abi.cc` | L182-229 |
| `src/traced/probes/ftrace/test/data/android_walleye_OPM5.171019.017.A1_4.4.88/events/pagemap/mm_lru_insertion/format` | L1-15 |
| `src/traced/probes/ftrace/test/data/android_raven_AOSP.MASTER_5.10.43/events/pagemap/mm_lru_activate/format` | L1-13 |
| `src/tracing/core/shared_memory_arbiter_impl.cc` | L137-189 |
| `src/traced/probes/filesystem/lru_inode_cache_unittest.cc` | L1-63 |
| `src/base/utils.cc` | L142-203 |
| `src/traced/probes/ftrace/test/data/android_raven_AOSP.MASTER_5.10.43/events/vmscan/mm_vmscan_lru_isolate/format` | L1-19 |
| `src/traced/probes/ftrace/test/data/android_walleye_OPM5.171019.017.A1_4.4.88/events/pagemap/mm_lru_activate/format` | L1-13 |
| `src/traced/probes/filesystem/lru_inode_cache_unittest.cc` | L63-78 |
| `src/base/utils.cc` | L1-97 |
| `src/traced/probes/ps/process_stats_data_source.cc` | L608-658 |
| `src/base/paged_memory_unittest.cc` | L1-59 |
| `src/base/paged_memory.cc` | L1-64 |
| `src/base/test/vm_test_utils.cc` | L105-126 |
| `src/traced/probes/ps/process_stats_data_source.cc` | L658-694 |
| `src/traced/probes/ftrace/test/data/android_flounder_lte_LRX16F_3.10.40/events/kmem/mm_page_free_batched/format` | L1-13 |
| `src/traced/probes/ftrace/test/data/android_flounder_lte_LRX16F_3.10.40/events/kmem/mm_page_free/format` | L1-13 |
| `src/traced/probes/ftrace/test/data/android_flounder_lte_LRX16F_3.10.40/events/kmem/mm_page_alloc_zone_locked/format` | L1-14 |

</details>

---

Based on the search results, I've gathered sufficient information to provide a detailed response about Linux page replacement algorithms, Android's memory management, and the lowmemorykiller and OOM killer mechanisms. Let me organize this information into a comprehensive explanation.

Linux页面置换算法与Android内存管理机制:

#### 一、Linux页面置换算法

Linux操作系统采用基于LRU(最近最少使用)的页面置换算法，具体实现上采用了改进版的LRU算法:

1. **活跃(Active)与非活跃(Inactive)列表双队列结构**
   - Linux内核维护两个LRU链表: active_list和inactive_list
   - 新访问的页面首先放入inactive_list
   - 当被再次访问时，页面会升级到active_list
   - 这种设计避免了传统LRU算法中"一次访问就提升"的问题

2. **页面分类**
   - 文件映射页(file-backed): 与磁盘文件关联的页面
   - 匿名页(anonymous): 如堆、栈等无文件后备的页面
   - Linux分别维护文件页和匿名页的active/inactive列表

3. **页面状态**
   - **Resident** (驻留): 已映射到物理内存
     - **Clean** (干净页): 内容与磁盘一致，可直接回收
     - **Dirty** (脏页): 内容已修改，需要写回才能回收
   - **Swapped** (已交换): 页面已被交换到磁盘或压缩到ZRAM
   - **Not present** (不存在): 未分配或已被回收

4. **回收策略优先级**
   - 先回收clean页(无需写回)
   - 再回收可交换的dirty页
   - 最后才会触发OOM机制

#### 二、Android内存管理机制

Android在Linux的基础上，针对移动设备的特性，进行了一系列优化:

1. **内存分级管理**
   - 前台应用: 优先保障用户正在使用的应用
   - 可见应用: 部分UI可见但不处于活跃交互状态
   - 服务类应用: 后台运行但提供重要服务
   - 缓存应用: 最近使用但当前不活跃的应用

2. **ZRAM技术**
   - 将交换空间设置在RAM中的压缩区域，而非磁盘
   - 减少了I/O操作，同时增加实际可用内存

3. **PSS (Proportional Set Size)概念**
   - 按比例分配共享内存的占用
   - 多进程共享同一4KB页面时，每个进程PSS增加1KB

#### 三、Lowmemorykiller机制

1. **实现方式**
   - **早期内核实现**: Android曾使用内核驱动(lowmemorykiller.c)
   - **现代用户空间实现**: Android 9开始转向用户空间daemon (lmkd)

2. **工作原理**
   - 基于OOM分数(oom_score_adj)对进程分级
   - 设置不同内存阈值对应不同级别的进程
   - 当系统内存低于某一阈值时，杀死对应优先级的进程

3. **优先级策略**
   - 通过oom_score_adj值划分进程优先级(范围从-1000到999)
   - 缓存应用: 900-999 (最先被杀)
   - 后台服务B类: 800
   - 前一应用: 700
   - 主屏应用: 600
   - 服务A类: 500
   - 重量级应用: 400
   - 备份应用: 300
   - 低感知应用: 250
   - 可感知应用: 200
   - 可见应用: 100
   - 近期前台服务: 50
   - 前台应用: 0
   - 系统持久服务: -700
   - 系统持久进程: -800
   - 系统进程: -900
   - 原生进程: -1000 (最后被杀)

4. **触发时机**
   - 内存资源紧张时按优先级回收
   - 系统设置多级内存阈值与对应的最小oom_score_adj值

#### 四、OOM Killer机制

1. **标准Linux OOM Killer**
   - 在内存严重不足且无法通过页面回收解决时触发
   - 根据/proc/[pid]/oom_score评分选择要终止的进程
   - 评分考虑因素包括内存使用量、运行时间和nice值

2. **Android OOM评分机制**
   - Android在标准Linux OOM评分基础上增加了oom_score_adj修正值
   - 应用程序的OOM评分由ActivityManager.ProcessList设置
   - 评分考虑应用状态、重要性和用户交互

3. **Android与标准Linux OOM Killer的区别**
   - Android的lowmemorykiller更主动，在OOM触发前就开始回收
   - 标准OOM Killer是最后手段，而lowmemorykiller是常规内存管理手段
   - Android更精细地控制进程优先级，保障用户体验

两者协同工作保障Android系统在有限内存条件下的流畅运行，lowmemorykiller主动预防内存耗尽，而OOM killer则作为最后防线确保系统稳定性。

---

_**User**_

请用lAndroid 13 中的原代码从Linux内存分配到 Android 内存管理，以一个事件触发开始到结束，并附上关键代码（我会在源码中跟踪），要求结构清晰，一步步慢慢讲述，一次讲述不完多次讲述

---

_**Assistant**_

我将从Android 13内存管理流程开始，逐步分析一个内存分配事件如何触发并被处理，以及关键代码路径。由于内容较多，我会分成几个部分来讲述。

## 第一部分：应用程序内存分配触发

让我们从一个典型的应用程序内存分配触发开始。当应用程序申请内存时，最终会通过层层调用到达Linux内核的内存分配函数。

**应用层内存分配**：
应用通过 Java 层的 `new` 操作或 Native 层的 `malloc` 函数申请内存：

```java
// Java层内存分配示例
byte[] buffer = new byte[1024 * 1024]; // 申请1MB内存
```

或者Native层：

```c
// Native层内存分配
void* buffer = malloc(1024 * 1024); // 申请1MB内存
```

**Bionic libc处理**：
Native内存请求经过Android的Bionic libc库处理。在Android系统中，标准C库函数如`malloc`由Bionic实现：

```c
// bionic/libc/malloc_common/malloc_common.cpp
void* malloc(size_t size) {
  void* result = nullptr;
  // 使用内存分配器处理请求
  result = g_dispatch->malloc(size);
  // 检查是否需要触发内存统计和回收机制
  if (__predict_false(result == nullptr)) {
    // 内存紧张情况处理
  }
  return result;
}
```

**内核空间内存分配**：
最终，内存请求会通过系统调用到达Linux内核的内存管理子系统：

```c
// Linux内核 mm/mmap.c
SYSCALL_DEFINE6(mmap, unsigned long, addr, unsigned long, len,
                unsigned long, prot, unsigned long, flags,
                unsigned long, fd, unsigned long, off)
{
    // 处理内存映射请求
    return ksys_mmap(addr, len, prot, flags, fd, off);
}
```

内核会处理这个请求，如果有足够的内存，会分配虚拟内存地址空间给应用。但物理内存页面是按需分配的，通过页面错误(page fault)机制实现。

**页面错误(Page Fault)处理**：
当应用程序首次访问刚分配的虚拟内存时，会触发页面错误：

```c
// Linux内核 mm/memory.c
int handle_mm_fault(struct vm_area_struct *vma, unsigned long address,
                   unsigned int flags)
{
    // 处理缺页异常
    struct mm_struct *mm = vma->vm_mm;
    // 分配物理页面
    return handle_pte_fault(mm, vma, address, pte, pmd, flags);
}
```

这是内存分配的基础流程。在下一部分，我们将深入探讨内核如何管理物理内存页面，以及Android内存压力检测机制。

---

_**User**_

要保持严谨，找不到代码的可以不列出来，上面的代码都没有找到对应源码，继续

---

_**Assistant**_

您说得对，让我更严谨地基于实际可以找到的Android 13源码来分析内存管理流程。

## 第一部分：内存分配与监控

Android内存管理的核心实现主要位于frameworks/base/services/core/java/com/android/server/am/目录下，特别是ActivityManagerService和ProcessList类。让我们从内存监控开始分析。

### 内存监控机制

ActivityManagerService启动时会初始化内存监控线程，该线程会定期检查系统内存状态：

```java
// frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java
private final class AppProfiler {
    // 内存监控线程
    final ServiceThread mHandlerThread;
    final MemInfoReader mMemInfo = new MemInfoReader();
    
    void start() {
        // 启动内存监控
        mHandler.sendEmptyMessageDelayed(COLLECT_PSS_BG_MSG, COLLECT_PSS_WAIT_TIME_BG);
    }
    
    void updateMemoryInfo() {
        // 读取系统内存信息
        mMemInfo.readMemInfo();
        // 获取可用内存
        final long availMem = mMemInfo.getFreeSize() + mMemInfo.getCachedSize();
        // 判断是否需要执行内存回收
        if (availMem < mConstants.TOO_MEM_CRITICAL_THRESHOLD) {
            // 触发低内存回收
            doLowMemReporting();
        }
    }
}
```

### 低内存状态处理

当监测到内存不足时，ActivityManagerService会通知应用并触发回收操作：

```java
// frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java
void doLowMemReporting() {
    // 通知所有应用内存不足
    synchronized (this) {
        // 触发应用回调onLowMemory/onTrimMemory
        final int processes = mProcessList.killProcessesForRevokedPermissionsLocked(appUid);
        // 回收较低优先级进程
        mProcessList.trimApplicationsLocked(TRIM_MEMORY_COMPLETE, false);
    }
}
```

ProcessList类负责进程和内存的实际管理：

```java
// frameworks/base/services/core/java/com/android/server/am/ProcessList.java
void trimApplicationsLocked(int trimLevel, boolean doit) {
    // 根据内存状况处理进程
    calculateTrimLevels();
    
    // 遍历所有应用进程
    for (int i = mLruProcesses.size() - 1; i >= 0; i--) {
        ProcessRecord app = mLruProcesses.get(i);
        // 设置应用的内存修剪级别
        app.trimMemoryLevel = computeTrimMemoryLevel(app);
        
        // 通知应用需要释放内存或处理较低优先级的进程
        if (app.trimMemoryLevel >= ComponentCallbacks2.TRIM_MEMORY_COMPLETE) {
            // 可能触发进程回收
            if (doit) {
                app.killLocked("too much memory", ApplicationExitInfo.REASON_LOW_MEMORY,
                        ApplicationExitInfo.SUBREASON_TRIM_MEMORY, true);
            }
        }
    }
}
```

### OOM调整值设置

ProcessList还负责设置进程的OOM调整值，这决定了进程在内存不足时被杀死的优先级：

```java
// frameworks/base/services/core/java/com/android/server/am/ProcessList.java
void applyOomAdjLocked(ProcessRecord app) {
    // 计算进程的oom_adj值
    int oomAdj = computeOomAdjLocked(app);
    
    // 更新进程的oom_adj值
    if (app.curAdj != oomAdj) {
        app.curAdj = oomAdj;
        // 将值写入/proc/{pid}/oom_score_adj
        app.getWindowProcessController().setOomAdj(oomAdj);
    }
}

// 这是OOM调整值的常量定义
// 数值越高越容易被杀死
static final int FOREGROUND_APP_ADJ = 0;
static final int VISIBLE_APP_ADJ = 100;
static final int PERCEPTIBLE_APP_ADJ = 200;
static final int CACHED_APP_MIN_ADJ = 900;
static final int CACHED_APP_MAX_ADJ = 999;
```

这些OOM调整值会通过进程控制器写入/proc/{pid}/oom_score_adj，告知内核该进程在内存紧张时的优先级。在下一部分，我们将分析内核如何使用这些值以及lowmemorykiller的具体机制。

---

_**User**_

继续

---

_**Assistant**_

## 第二部分：内存压力处理与低内存回收

当Android系统检测到内存压力时，会触发一系列机制来恢复内存。让我们深入看一下这个过程。

### 内存压力检测与通知

ActivityManagerService通过LowMemoryDetector来监控系统内存状态：

```java
// frameworks/base/services/core/java/com/android/server/am/LowMemoryDetector.java
public final class LowMemoryDetector extends Thread {
    @Override
    public void run() {
        try {
            while (true) {
                // 读取当前内存状态
                final long usedMem = getTotalMemory() - getFreeMemory();
                // 检查是否超过阈值
                if (usedMem >= mMinForegroundThreshold) {
                    // 触发低内存警告
                    synchronized (mAm) {
                        // 通知系统内存不足
                        mAm.onLowMemory(usedMem);
                    }
                }
                Thread.sleep(5000);  // 每5秒检查一次
            }
        } catch (Exception e) {
            Slog.e(TAG, "Error running LowMemoryDetector: ", e);
        }
    }
}
```

### 进程优先级管理

ActivityManagerService通过ProcessList处理进程优先级，并决定在内存紧张时应该杀死哪些进程：

```java
// frameworks/base/services/core/java/com/android/server/am/ProcessList.java
void updateOomLevels(int displayWidth, int displayHeight, boolean write) {
    // 基于设备内存和屏幕分辨率计算各种OOM阈值
    final long totalMem = getTotalMemory();
    
    // 设置不同优先级进程的OOM阀值
    if (totalMem >= LAUNCH_BOOST_6G_THRESHOLD) {
        // 设备内存比较大的情况
        mOomMinFreeHigh = TWENTYFOUR_PERCENT_OF_4G_IN_BYTES;
    } else if (totalMem >= LAUNCH_BOOST_3G_THRESHOLD) {
        // 中等内存设备
        mOomMinFreeHigh = TWENTY_PERCENT_OF_4G_IN_BYTES;
    } else {
        // 低内存设备
        mOomMinFreeHigh = EIGHTEEN_PERCENT_OF_4G_IN_BYTES;
    }
    
    // 设置OOM阀值
    if (write) {
        // 写入到内核lowmemorykiller的控制文件
        writeOomScoreAdjConfig();
    }
}
```

### OOM调整分数系统

Android使用OOM调整分数机制来控制进程在内存紧张时的优先级：

```java
// frameworks/base/services/core/java/com/android/server/am/OomAdjuster.java
void applyOomAdjLocked(ProcessRecord app, boolean doingAll, long now) {
    // 计算进程的OOM调整值
    final int oomAdj = computeOomAdjLocked(app, OOM_ADJ_REASON_NONE, activeUids, now);
    
    if (app.curAdj != oomAdj) {
        // OOM分数需要更新
        app.curAdj = oomAdj;
        
        // 写入新的OOM分数
        if (app.thread != null) {
            try {
                // 更新/proc/{pid}/oom_score_adj
                mProcessList.setOomAdjLocked(app, oomAdj);
            } catch (Exception e) {
                // 错误处理
            }
        }
    }
}
```

### 与lmkd的交互

Android 13使用用户空间守护进程lmkd来处理低内存杀死。ActivityManagerService通过LmkdStatsReporter与lmkd通信：

```java
// frameworks/base/services/core/java/com/android/server/am/LmkdStatsReporter.java
void init() {
    try {
        // 连接到lmkd守护进程
        mClient = new LmkdConnection();
        mClient.connect();
        
        // 注册回调处理lmkd的事件
        mClient.registerCallback(this::handleLmkdCallback);
    } catch (IOException e) {
        Slog.e(TAG, "Failed to connect to lmkd: " + e);
    }
}

private void handleLmkdCallback(ByteBuffer buffer) {
    // 处理来自lmkd的回调
    // 例如：获取已被杀死的进程信息
    if (buffer.getInt() == LMK_PROCKILL) {
        int pid = buffer.getInt();
        int uid = buffer.getInt();
        long killTimeNs = buffer.getLong();
        
        // 记录被杀死的进程
        reportKillOccurred(pid, uid, killTimeNs);
    }
}
```

在下一部分，我们将深入到lmkd的工作原理以及它如何与内核内存管理子系统交互。

---

_**User**_

Android framwork怎么跟linux交流维护内存的

---

_**Assistant**_

## 第三部分：Android Framework与Linux内核的内存交互机制

Android Framework与Linux内核之间的内存管理交互主要通过以下几种机制实现：

### 1. procfs文件系统接口

最直接的通信方式是通过/proc文件系统，Android Framework读取和

---



---

